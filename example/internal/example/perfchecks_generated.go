// Code generated by fenneg version v0.8.3+dirty. DO NOT EDIT.

package example

import (
	"encoding/binary"

	"github.com/sirkon/errors"
)

func PerfcheckLen(p *Perfcheck) int {
	if p == nil {
		return 0
	}

	return 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8
}

func PerfcheckEncode(dst []byte, p *Perfcheck) []byte {
	if p == nil {
		return dst
	}
	if dst == nil {
		dst = make([]byte, 0, PerfcheckLen(p))
	}

	// Encode F0(int64).
	dst = binary.LittleEndian.AppendUint64(dst, uint64(p.F0))

	// Encode F1(int64).
	dst = binary.LittleEndian.AppendUint64(dst, uint64(p.F1))

	// Encode F2(int64).
	dst = binary.LittleEndian.AppendUint64(dst, uint64(p.F2))

	// Encode F3(int64).
	dst = binary.LittleEndian.AppendUint64(dst, uint64(p.F3))

	// Encode F4(int64).
	dst = binary.LittleEndian.AppendUint64(dst, uint64(p.F4))

	// Encode F5(int64).
	dst = binary.LittleEndian.AppendUint64(dst, uint64(p.F5))

	// Encode F6(int64).
	dst = binary.LittleEndian.AppendUint64(dst, uint64(p.F6))

	// Encode F7(int64).
	dst = binary.LittleEndian.AppendUint64(dst, uint64(p.F7))

	// Encode F8(int64).
	dst = binary.LittleEndian.AppendUint64(dst, uint64(p.F8))

	// Encode F9(int64).
	dst = binary.LittleEndian.AppendUint64(dst, uint64(p.F9))

	return dst
}

// PerfcheckEncode decodes content of Perfcheck.
func PerfcheckDecode(p *Perfcheck, src []byte) (err error) {
	// Decode F0(int64).
	if len(src) < 8 {
		return errors.New("decode p.F0(int64): record buffer is too small").Uint64("length-required", uint64(8)).Int("length-actual", len(src))
	}
	p.F0 = int64(binary.LittleEndian.Uint64(src))
	src = src[8:]

	// Decode F1(int64).
	if len(src) < 8 {
		return errors.New("decode p.F1(int64): record buffer is too small").Uint64("length-required", uint64(8)).Int("length-actual", len(src))
	}
	p.F1 = int64(binary.LittleEndian.Uint64(src))
	src = src[8:]

	// Decode F2(int64).
	if len(src) < 8 {
		return errors.New("decode p.F2(int64): record buffer is too small").Uint64("length-required", uint64(8)).Int("length-actual", len(src))
	}
	p.F2 = int64(binary.LittleEndian.Uint64(src))
	src = src[8:]

	// Decode F3(int64).
	if len(src) < 8 {
		return errors.New("decode p.F3(int64): record buffer is too small").Uint64("length-required", uint64(8)).Int("length-actual", len(src))
	}
	p.F3 = int64(binary.LittleEndian.Uint64(src))
	src = src[8:]

	// Decode F4(int64).
	if len(src) < 8 {
		return errors.New("decode p.F4(int64): record buffer is too small").Uint64("length-required", uint64(8)).Int("length-actual", len(src))
	}
	p.F4 = int64(binary.LittleEndian.Uint64(src))
	src = src[8:]

	// Decode F5(int64).
	if len(src) < 8 {
		return errors.New("decode p.F5(int64): record buffer is too small").Uint64("length-required", uint64(8)).Int("length-actual", len(src))
	}
	p.F5 = int64(binary.LittleEndian.Uint64(src))
	src = src[8:]

	// Decode F6(int64).
	if len(src) < 8 {
		return errors.New("decode p.F6(int64): record buffer is too small").Uint64("length-required", uint64(8)).Int("length-actual", len(src))
	}
	p.F6 = int64(binary.LittleEndian.Uint64(src))
	src = src[8:]

	// Decode F7(int64).
	if len(src) < 8 {
		return errors.New("decode p.F7(int64): record buffer is too small").Uint64("length-required", uint64(8)).Int("length-actual", len(src))
	}
	p.F7 = int64(binary.LittleEndian.Uint64(src))
	src = src[8:]

	// Decode F8(int64).
	if len(src) < 8 {
		return errors.New("decode p.F8(int64): record buffer is too small").Uint64("length-required", uint64(8)).Int("length-actual", len(src))
	}
	p.F8 = int64(binary.LittleEndian.Uint64(src))
	src = src[8:]

	// Decode F9(int64).
	if len(src) < 8 {
		return errors.New("decode p.F9(int64): record buffer is too small").Uint64("length-required", uint64(8)).Int("length-actual", len(src))
	}
	p.F9 = int64(binary.LittleEndian.Uint64(src))
	src = src[8:]

	if len(src) > 0 {
		return errors.Newf("the buffer still has %d bytes left after the last argument decoded", len(src)).Int("record-bytes-left", len(src))
	}

	return nil
}
